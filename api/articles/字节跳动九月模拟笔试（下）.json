{"title":"字节跳动2022年9月模拟笔试（上）","uid":"8ff685f8218119a3e3b228fe1d1d8ae5","slug":"字节跳动九月模拟笔试（下）","date":"2022-09-08T13:57:00.000Z","updated":"2022-10-05T14:18:20.634Z","comments":true,"path":"api/articles/字节跳动九月模拟笔试（下）.json","keywords":null,"cover":"https://res.cloudinary.com/dg7crzfct/image/upload/v1664951146/%E6%96%87%E7%AB%A0%E7%B4%A0%E6%9D%90%E5%BA%93/shahadat-rahman-gnyA8vd3Otc-unsplash_sufut6.jpg","content":"<h1 id=\"第三题：数组游戏\"><a href=\"#第三题：数组游戏\" class=\"headerlink\" title=\"第三题：数组游戏\"></a>第三题：数组游戏</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。</p>\n<p>凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。</p>\n<p>在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。</p>\n<p>小猫咪表示“我太难了”</p>\n<p>你能帮帮它么?</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h2 id=\"输入描述：\"><a href=\"#输入描述：\" class=\"headerlink\" title=\"输入描述：\"></a>输入描述：</h2><p>会有多组询问</p>\n<p>首先输入一个数字接下来有组数据</p>\n<p>每组数据里，首先会有一个数，表示接下来这个数列的长度为</p>\n<p>然后接下来一行会有n个数字，从左到右表示题目所说的数列，每个数字</p>\n<h2 id=\"输出描述：\"><a href=\"#输出描述：\" class=\"headerlink\" title=\"输出描述：\"></a>输出描述：</h2><p>对于每一个提问，请依次输出最多可以选取多少个数</p>\n<h2 id=\"备注：\"><a href=\"#备注：\" class=\"headerlink\" title=\"备注：\"></a>备注：</h2><p>每个数字（）（</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h4 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h4><p>2</p>\n<p>6</p>\n<p>4 -4 1 -3 -1 -3</p>\n<p>5</p>\n<p>1 2 3 4 5</p>\n<h4 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h4><p>5</p>\n<p>5</p>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>第一组数据：选取1，3，4，5，6个数；</p>\n<p>第二组数据，全部正数，那就全选。</p></blockquote>\n<h2 id=\"解法\"><a href=\"#解法\" class=\"headerlink\" title=\"解法\"></a>解法</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意：必须从左到右选取，不能直接排序选！！！！！必须保证中间过程所选数之和非负！！！</strong></p>\n<p>所以进行模拟，使用反悔贪心+优先队列（没错，又是他），规则如下：</p>\n<ul>\n<li>遇到正数或者零：直接选</li>\n<li>遇到负数</li>\n<li>选了之后sum &gt;&#x3D; 0，那么直接选，但是要存入优先队列（小根堆）中</li>\n<li>选了之后sum &lt; 0，那么在已经选择的负数中置换出一个最小的（前提是当前这个数是比已选负数的最小值要大的）</li>\n</ul>\n<p><em>注：因为JS没有内置的优先队列函数，我不想自己写一个，所以这里每次在队列加入元素都会使用一次sort函数，这样可以保证维护一个小根堆。</em></p></blockquote>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">const rl &#x3D; readline.createInterface(&#123;\n    input: process.stdin,\n    output: process.stdout,\n&#125;);\nlet cur_line &#x3D; 0;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n    if (cur_line &lt; 2) &#123;\n        cur_line +&#x3D; 1;\n        return;\n    &#125;\n    if (cur_line % 2 &#x3D;&#x3D;&#x3D; 0) &#123;\n        let arr &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        &#x2F;&#x2F; console.log(arr, k);\n        console.log(&#39;******答案输出：&#39;, main(arr));\n    &#125;\n    cur_line++;\n&#125;);\n\nfunction main(arr) &#123;\n    let sum &#x3D; 0,\n        count &#x3D; 0,\n        q &#x3D; [];\n    while (arr.length) &#123;\n        let tmp &#x3D; arr.shift();\n        &#x2F;&#x2F; console.log(&#96;tmp:$&#123;tmp&#125;,q:$&#123;q&#125;,sum:$&#123;sum&#125;&#96;);\n        if (tmp &gt;&#x3D; 0) &#123;\n            sum +&#x3D; tmp;\n            count++;\n        &#125; else &#123;\n            if (sum + tmp &gt;&#x3D; 0) &#123;\n                sum +&#x3D; tmp;\n                q.push(tmp);\n                q.sort((a, b) &#x3D;&gt; a - b);\n                count++;\n            &#125; else &#123;\n                if (q.length !&#x3D; 0 &amp;&amp; q[0] &lt; tmp) &#123;\n                    sum &#x3D; sum - q.shift() + tmp;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return count;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"第四题：寻找对称的二叉树特定节点\"><a href=\"#第四题：寻找对称的二叉树特定节点\" class=\"headerlink\" title=\"第四题：寻找对称的二叉树特定节点\"></a>第四题：寻找对称的二叉树特定节点</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>给定一颗二叉树，二叉树每个节点都有一个唯一的整数值代表节点，在遍历时，我们使用节点的整数值作为标记;结构对称，是指二叉树从根节点往下看，左右翻转一下，能够重合(不考虑节点内容比较，仅仅是结构)，我们就称这棵二叉树树结构对称</li>\n<li>输入:二叉树的节点个数N (0&lt;N&lt;60000)、前序和中序遍历结果，分别是第一行、第二行与第三行;各个节点整数值在1到60000之间</li>\n<li>输出︰判断这棵二叉树是否结构对称，若对称请输出最大值节点在树中对称节点的整数值，不对称请直接输出最大值节点的整数值</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h2 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述\"></a>输入描述</h2><p>二叉树的前序和中序遍历结果，以数组序列表示</p>\n<p>第一行为节点个数N (0&lt;N&lt;60000)前序和中序遍历结果，输入分别是第二行与第三行</p>\n<h2 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述\"></a>输出描述</h2><p>判断这棵二叉树是否结构对称，若对称请输出最大值节点在树中对称节点的整数值，不对称请直接输出最大值节点的整数值</p>\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><p>1.每个节点都有一个唯一的整数值代表节点（但比赛中实际数据似乎并不是的），结构对称不考虑节点内容数字大小比较，仅仅是结构</p>\n<p>2.根节点相对自己是对称的</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><h2 id=\"示例1\"><a href=\"#示例1\" class=\"headerlink\" title=\"示例1\"></a>示例1</h2><h4 id=\"输入-1\"><a href=\"#输入-1\" class=\"headerlink\" title=\"输入\"></a>输入</h4><p>3</p>\n<p>1 3 4</p>\n<p>3 1 4</p>\n<h4 id=\"输出-1\"><a href=\"#输出-1\" class=\"headerlink\" title=\"输出\"></a>输出</h4><p>3</p>\n<h4 id=\"说明-1\"><a href=\"#说明-1\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>这颗二叉树根是1，左右子节点分别是3和4，是结构对称的，4是最大值节点，其对称节点是3，所以最后输出为3。</p>\n<h2 id=\"示例2\"><a href=\"#示例2\" class=\"headerlink\" title=\"示例2\"></a>示例2</h2><h4 id=\"输入-2\"><a href=\"#输入-2\" class=\"headerlink\" title=\"输入\"></a>输入</h4><p>5</p>\n<p>1 3 5 7 2</p>\n<p>5 3 1 2 7</p>\n<h4 id=\"输出-2\"><a href=\"#输出-2\" class=\"headerlink\" title=\"输出\"></a>输出</h4><p>7</p>\n<h4 id=\"说明-2\"><a href=\"#说明-2\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>这颗二叉树，节点7是数值最大的节点，但其节点2对称位置没有节点，二叉树不对称，所以输出为7。</p></blockquote>\n<h2 id=\"解法-1\"><a href=\"#解法-1\" class=\"headerlink\" title=\"解法\"></a>解法</h2><ul>\n<li>首先，根据前序遍历和中序遍历重建二叉树，这个具体怎么做看上篇公众号文章。</li>\n<li>然后，递归判断是否结构对称</li>\n<li>最后，如果对称，则输出最大值的对称节点；若不对称，则输出最大的节点值。</li>\n</ul>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">const &#123; func &#125; &#x3D; require(&#39;prop-types&#39;);\nconst readline &#x3D; require(&#39;readline&#39;);\nconst rl &#x3D; readline.createInterface(&#123;\n    input: process.stdin,\n    output: process.stdout,\n&#125;);\n\nlet cur_line &#x3D; 0,\n    preorder,\n    inorder;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n    if (cur_line &#x3D;&#x3D; 0) &#123;\n        cur_line++;\n        return;\n    &#125; else if (cur_line &#x3D;&#x3D; 1) &#123;\n        preorder &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        cur_line++;\n    &#125; else if (cur_line &#x3D;&#x3D; 2) &#123;\n        inorder &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        console.log(main(preorder, inorder));\n    &#125;\n&#125;);\n\n&#x2F;&#x2F; 定义二叉树\nfunction TreeNode(val, left, right) &#123;\n    this.val &#x3D; val &#x3D;&#x3D;&#x3D; undefined ? 0 : val;\n    this.left &#x3D; left &#x3D;&#x3D;&#x3D; undefined ? null : left;\n    this.right &#x3D; right &#x3D;&#x3D;&#x3D; undefined ? null : right;\n&#125;\n\n&#x2F;&#x2F; 递归重建二叉树\nfunction buildTree(preorder, inorder) &#123;\n    if (preorder.length &#x3D;&#x3D;&#x3D; 0) return null;\n    let mid_index &#x3D; inorder.indexOf(preorder[0]);\n    let root &#x3D; new TreeNode(preorder[0]);\n    root.left &#x3D; buildTree(preorder.slice(1, mid_index + 1), inorder.slice(0, mid_index));\n    root.right &#x3D; buildTree(preorder.slice(mid_index + 1), inorder.slice(mid_index + 1));\n    return root;\n&#125;\n\n&#x2F;&#x2F; 递归检查树的结构是否对称（无需比较值）\nfunction check(left, right) &#123;\n    &#x2F;&#x2F; 如果都为null，那么对称，返回1\n    if (!left &amp;&amp; !right) return 1;\n    &#x2F;&#x2F; 如果只有一方为null，那不对称，返回0\n    if (!left || !right) return 0;\n    return check(left.left, right.right) &amp;&amp; check(left.right, right.left);\n&#125;\n\nfunction main(preorder, inorder) &#123;\n    &#x2F;* 这个查找对称二叉树的对称节点写在了主函数里面，\n        因为如果写在外面，那么必须传入max_value，然后在函数内部定义pair_val并返回\n        写在主函数内部的一个好处是，只要保证max_value和pair_val和findPair在同一作用域\n        那么findPair内部就会向外层自动寻找这两个值，类似于闭包。\n     *&#x2F;\n    function findPair(left, right) &#123;\n        if (!left || !right) return;\n        if (left.val &#x3D;&#x3D;&#x3D; max_value) &#123;\n            pair_val &#x3D; right.val;\n        &#125;\n        if (right.val &#x3D;&#x3D;&#x3D; max_value) &#123;\n            pair_val &#x3D; left.val;\n            return pair_val;\n        &#125;\n        &#x2F;&#x2F; 继续往下找\n        findPair(left.left, right.right);\n        findPair(left.right, right.left);\n    &#125;\n\n    &#x2F;&#x2F; 最大节点值对称点的值，先声明\n    &#x2F;&#x2F; 这里注意，必须在和findPair函数一级的作用域定义，\n    &#x2F;&#x2F; 因为如果在let在下方的if语句中定义，findPair会找不到pair_val\n    let pair_val;\n    &#x2F;&#x2F; 最大节点值\n    let max_value &#x3D; Math.max(...preorder);\n    let root &#x3D; buildTree(preorder, inorder);\n    let flag &#x3D; check(root.left, root.right);\n    if (flag) &#123;\n        &#x2F;&#x2F; 对称\n        findPair(root.left, root.right); &#x2F;&#x2F; 注意findPair的主要目的是修改pair_val，而非返回一个结果\n        return pair_val;\n    &#125; else &#123;\n        &#x2F;&#x2F; 非对称\n        return max_value;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本次9月排名赛的四道题都放在了飞书文档公开，欢迎访问：</p>\n<p><a href=\"https://bytedancecampus1.feishu.cn/docx/doxcnz5i6ZoB0PYNkUCEmoEXyRg\">https://bytedancecampus1.feishu.cn/docx/doxcnz5i6ZoB0PYNkUCEmoEXyRg</a></p>\n<p><img src=\"https://res.cloudinary.com/dg7crzfct/image/upload/v1664952028/%E6%96%87%E7%AB%A0%E7%B4%A0%E6%9D%90%E5%BA%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221005143924_mazzbj.jpg\" alt=\"图片\"></p></blockquote>\n","text":"第三题：数组游戏 双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。 凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。 在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。 小猫咪表示“我太难了...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":4,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":4,"path":"api/tags/数据结构.json"},{"name":"二叉树","slug":"二叉树","count":2,"path":"api/tags/二叉树.json"},{"name":"字节跳动","slug":"字节跳动","count":2,"path":"api/tags/字节跳动.json"},{"name":"优先队列","slug":"优先队列","count":3,"path":"api/tags/优先队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%9A%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">第三题：数组游戏</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">输入描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">输出描述：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%87%E6%B3%A8%EF%BC%9A\"><span class=\"toc-text\">备注：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">输入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">输出</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B3%95\"><span class=\"toc-text\">解法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E9%A2%98%EF%BC%9A%E5%AF%BB%E6%89%BE%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E5%AE%9A%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">第四题：寻找对称的二叉树特定节点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">输入描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">输出描述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%87%E6%B3%A8\"><span class=\"toc-text\">备注</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B1\"><span class=\"toc-text\">示例1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5-1\"><span class=\"toc-text\">输入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA-1\"><span class=\"toc-text\">输出</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-1\"><span class=\"toc-text\">说明</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B2\"><span class=\"toc-text\">示例2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5-2\"><span class=\"toc-text\">输入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA-2\"><span class=\"toc-text\">输出</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E-2\"><span class=\"toc-text\">说明</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B3%95-1\"><span class=\"toc-text\">解法</span></a></li></ol></li></ol>","author":{"name":"风离","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"略懂数据挖掘、NLP和推荐算法的前炼丹师，目前沉迷JS、React的前端硕狗。 <br /> @ <b>公众号：丹星X</b>","socials":{"github":"https://github.com/leek-emperor","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/ma-xing-yu-71","csdn":"https://blog.csdn.net/weixin_44008395?type=blog","juejin":"https://juejin.cn/user/1042800253352664","customs":{}}},"mapped":true,"prev_post":{"title":"爬虫前置——页面和网络相关知识","uid":"66b66ee279145d8f8b0e567a448e4840","slug":"爬虫前置——网页和网络相关","date":"2022-10-10T07:00:00.000Z","updated":"2022-10-10T07:11:15.270Z","comments":true,"path":"api/articles/爬虫前置——网页和网络相关.json","keywords":null,"cover":"https://res.cloudinary.com/dg7crzfct/image/upload/v1665384096/%E6%96%87%E7%AB%A0%E7%B4%A0%E6%9D%90%E5%BA%93/R%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%9A%84HTML%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/jackson-sophat-_t-l5FFH8VA-unsplash_f8htiv.jpg","text":"HTML什么是HTML？ 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 前端三件套：HTML、CSS和Javascript。 HTML和CSS不算是编程语言。HTML更像是一个Word，可以写文字、插...","link":"","photos":[],"count_time":{"symbolsCount":551,"symbolsTime":"1 mins."},"categories":[{"name":"前端","slug":"前端","count":2,"path":"api/categories/前端.json"}],"tags":[{"name":"HTML","slug":"HTML","count":1,"path":"api/tags/HTML.json"},{"name":"CSS","slug":"CSS","count":1,"path":"api/tags/CSS.json"},{"name":"HTTP","slug":"HTTP","count":1,"path":"api/tags/HTTP.json"},{"name":"XML","slug":"XML","count":1,"path":"api/tags/XML.json"}],"author":{"name":"风离","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"略懂数据挖掘、NLP和推荐算法的前炼丹师，目前沉迷JS、React的前端硕狗。 <br /> @ <b>公众号：丹星X</b>","socials":{"github":"https://github.com/leek-emperor","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/ma-xing-yu-71","csdn":"https://blog.csdn.net/weixin_44008395?type=blog","juejin":"https://juejin.cn/user/1042800253352664","customs":{}}}},"next_post":{"title":"JSONP解决跨域问题","uid":"e0afe5470d30cea57d222ddde269ba0c","slug":"JSONP解决跨域","date":"2022-08-20T12:17:00.000Z","updated":"2022-10-05T06:50:24.466Z","comments":true,"path":"api/articles/JSONP解决跨域.json","keywords":null,"cover":"https://res.cloudinary.com/dg7crzfct/image/upload/v1664952605/%E6%96%87%E7%AB%A0%E7%B4%A0%E6%9D%90%E5%BA%93/JSONP%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/deepmind-OVzy5oIDPp8-unsplash_xqqxrb.jpg","text":"JSONP是JSON with Padding的略称，JSONP为民间提出的一种跨域解决方案，通过客户端的script标签发出的请求方式。 什么时候才有跨域问题?浏览器的ajax，去请求不同的源的数据，就会出现跨域问题。 问: img&#x2F;srcipt标签的src有跨域问题...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":2,"path":"api/categories/前端.json"}],"tags":[{"name":"网络请求","slug":"网络请求","count":1,"path":"api/tags/网络请求.json"},{"name":"JSONP","slug":"JSONP","count":1,"path":"api/tags/JSONP.json"},{"name":"Javascript","slug":"Javascript","count":1,"path":"api/tags/Javascript.json"}],"author":{"name":"风离","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"略懂数据挖掘、NLP和推荐算法的前炼丹师，目前沉迷JS、React的前端硕狗。 <br /> @ <b>公众号：丹星X</b>","socials":{"github":"https://github.com/leek-emperor","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/ma-xing-yu-71","csdn":"https://blog.csdn.net/weixin_44008395?type=blog","juejin":"https://juejin.cn/user/1042800253352664","customs":{}}}}}