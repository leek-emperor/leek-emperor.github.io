[{"id":"7de360a3c5a4628d6c3bdcf00d588e7c","title":"一个倒霉蛋的周赛日记","content":"大家好，这里是丹星，今天作为重回周赛的第二周，终于创下了历史记录——拿满18分。但是因为JS在力扣的奇怪Bug，我第四道题被卡在84％，所以面板上还是三道题12分。\n不否认本周的周赛题目确实比较简单，第一名的大佬在9分钟内就完成了四道题，那时候我刚写完第二题。\n\n第一题 最小偶倍数给你一个正整数 n ，返回 2 和 n 的最小公倍数（正整数）。\n\n\n\n\n\n\n\n\n\n输入：n &#x3D; 5\n输出：10\n解释：5 和 2 的最小公倍数是 10 。\n一道侮辱智商的题目，不解释\nvar smallestEvenMultiple = function(n) &#123;\n    if(n % 2 == 0)&#123;\n        return n\n    &#125;else&#123;\n        return n * 2;\n    &#125;\n&#125;;\n\n第二题 最长的字母序连续子字符串的长度字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 “abcdefghijklmnopqrstuvwxyz” 的任意子字符串都是 字母序连续字符串 。\n例如，”abc” 是一个字母序连续字符串，而 “acb” 和 “za” 不是。给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。\n\n\n\n\n\n\n\n\n\n输入：s &#x3D; “abacaba”\n输出：2\n解释：共有 4 个不同的字母序连续子字符串 “a”、”b”、”c” 和 “ab” 。“ab” 是最长的字母序连续子字符串。\n这个也挺简单的，只需要判断第i个字符串和第i-1个字符串是否是连续的就行（根据ASCII码）\nvar longestContinuousSubstring = function(s) &#123;\n    let ans = 1,\n        tmp = 1;\n    for(let i = 1; i &lt; s.length; i++)&#123;\n        if(s[i].charCodeAt() - s[i - 1].charCodeAt() == 1)&#123;\n            tmp++;\n        &#125;else&#123;\n            ans = Math.max(tmp, ans);\n            tmp = 1;\n        &#125;\n    &#125;\n    return Math.max(ans,tmp);\n&#125;;\n第三题 反转二叉树的奇数层给你一棵完美二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。\n\n例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。\n\n反转后，返回树的根节点。\n完美二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。\n节点的 层数 等于该节点到根节点之间的边数。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入：root &#x3D; [2,3,5,8,13,21,34]\n输出：[2,5,3,8,13,21,34]\n解释：\n这棵树只有一个奇数层。\n在第 1 层的节点分别是 3、5 ，反转后为 5、3 。\n一看到树当然就要想到递归或者迭代啦，或者DFS和BFS。这道题我用的BFS，但是应该还有更好的解法，毕竟我同时用了三个栈。\nvar reverseOddLevels = function(root) &#123;\n    let n = 0,\n        stack = [root],\n        node_stack = [],\n        val_stack = [],\n        flag = 1;\n    while(flag)&#123;\n        if(n % 2 == 0)&#123;\n            // 因为是完美二叉树，所以只要出现节点为null\n            // 就说明到了最后一层，直接跳出\n            if(stack[0].left == null)&#123;\n                flag = 0;\n                break;\n            &#125;\n            while(stack.length)&#123;\n                const node = stack.shift();\n                node_stack.push(node.left, node.right);\n                val_stack.push(node.left.val, node.right.val);\n            &#125;\n            while(val_stack.length)&#123;\n                const node = node_stack.shift(),\n                      val = val_stack.pop();\n                node.val = val;\n                stack.push(node);\n            &#125;\n            n++;\n        &#125;else&#123;\n            // 奇数层，已经完成了逆转，现在stack是满的，\n            // node_stack和val_stack为空，\n            // 我们要把下一个偶数层的node全部存到stack里面，\n            // 也就是替换掉stack里面的节点\n            if(stack[0].left == null)&#123;\n                flag = 0;\n                break;\n            &#125;\n            let currentLen = stack.length;\n            for(let i = 0; i &lt; currentLen; i++)&#123;\n                let tmp = stack.shift();\n                stack.push(tmp.left,tmp.right);\n            &#125;\n            n++;\n        &#125;\n    &#125;\n    return root;\n&#125;;\n第四题 字符串的前缀分数和给你一个长度为 n 的数组 words ，该数组由 非空 字符串组成。\n定义字符串 word 的 分数 等于以 word 作为 前缀 的 words[i] 的数目。\n\n例如，如果 words &#x3D; [“a”, “ab”, “abc”, “cab”] ，那么 “ab” 的分数是 2 ，因为 “ab” 是 “ab” 和 “abc” 的一个前缀。\n\n返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。\n注意：字符串视作它自身的一个前缀。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入：words &#x3D; [“abc”,”ab”,”bc”,”b”]\n输出：[5,4,3,2]\n解释：对应每个字符串的答案如下：\n\n“abc” 有 3 个前缀：”a”、”ab” 和 “abc” 。\n2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” ，1 个字符串的前缀为 “abc” 。\n\n总计 answer[0] &#x3D; 2 + 2 + 1 &#x3D; 5 。\n\n“ab” 有 2 个前缀：”a” 和 “ab” 。\n2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” 。\n\n总计 answer[1] &#x3D; 2 + 2 &#x3D; 4 。\n\n“bc” 有 2 个前缀：”b” 和 “bc” 。\n2 个字符串的前缀为 “b” ，1 个字符串的前缀为 “bc” 。\n\n总计 answer[2] &#x3D; 2 + 1 &#x3D; 3 。\n\n“b” 有 1 个前缀：”b”。\n2 个字符串的前缀为 “b” 。\n\n总计 answer[3] &#x3D; 2 。\n这道题最正统的解法应该是字典树，但是——我不会。不过我还是想出了另外一种更加通俗易懂的解法。\n\n首先，遍历每一个单词，用哈希表存储所有的前缀词。如果前缀词存在，则计数+1；如果不存在则计数为1.\n在存储哈希表时，维护一个栈，这个栈里面存储对应单词的所有前缀，所以这个栈存的元素也是列表\n最后，遍历栈，根据哈希表可以查找到对应单词所有前缀和的计数，相加，得到对应位置的值。Javascript版：var sumPrefixScores = function (words) &#123;\n\tif (words.length == 1) &#123;\n\t\treturn [words[0].length];\n\t&#125;\n\tlet map = &#123;&#125;,\n\t\tans = [];\n\tfor (let word of words) &#123;\n\t\tlet right = 1,\n\t\t\ttmp = [];\n\t\twhile (right &lt;= word.length) &#123;\n\t\t\tlet s = word.slice(0, right);\n\t\t\tif (map[s] == undefined) &#123;\n\t\t\t\tmap[s] = 1;\n\t\t\t&#125; else &#123;\n\t\t\t\tmap[s]++;\n\t\t\t&#125;\n\t\t\ttmp.push(s);\n\t\t\tright++;\n\t\t&#125;\n\t\tans.push(tmp);\n\t&#125;\n\tlet res = [];\n\tfor (let arr of ans) &#123;\n\t\tlet sum = 0;\n\t\tarr.forEach(val => &#123;\n\t\t\tsum += map[val];\n\t\t&#125;);\n\t\tres.push(sum);\n\t&#125;\n\treturn res;\n&#125;;\n这个解法在Leetcode第32个用例中爆出莫名错误，但是在本地运行无碍。比赛中我一度认为是这个方法没有考虑到一些特殊情况，但是在周赛结束后，我发现一位前排大佬的Python版本代码和我的思路一致。def sumPrefixScores(words):\n    count =  defaultdict(int)\n    for word in words:\n        m = len(word)\n        for i in range(1, m+1):\n            count[word[:i]] += 1\n            \n    ans = []\n    for word in words:\n        m = len(word)\n        cur = 0\n        for i in range(1, m+1):\n            cur += count[word[:i]]\n        ans.append(cur)\n    return ans\n\n我不管！！！这周周赛我就是满分，这不是超时，我本地代码跑那个例子也只用了2s。\n力扣还我血汗分！！！\n\n\n\n\n\n\n\n\n\n\n欢迎关注这个摸鱼更新的公众号\n\n","slug":"一个倒霉蛋的周赛日记","date":"2022-09-18T10:00:00.000Z","categories_index":"","tags_index":"","author_index":"风离"},{"id":"ccd980cab5c75bdd94e2c8b8c13252bb","title":"数据结构（四）优先队列/大小根堆","content":"大家好，这里是丹星，又来更新数据结构啦，今天也是老朋友啦，因为之前的几篇文章都提到了它：优先队列，又叫小&#x2F;大根堆。为什么这么快更新呢，因为昨天力扣周赛遇到这个被打爆啦，因为发现了之前总是用sort模拟小根堆也不是办法呀，还是得自己会写。\nWhat is the 堆  ?其实堆不是一个需要我们从头开始定义的一个数据结构，它的本质是用数组去模拟完全二叉树。为什么说是用数组去模拟树呢，因为它并不是真的要去定一个二叉树类，而是本质上还是对数组进行操作。\n二叉树大家都不陌生，那我们讲下以下两个定义。如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树，如：\n\n如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n\n那么一个数组，就可以被看作是一个完全二叉树，也就是一个堆，比如Array &#x3D; array &#x3D; [7,3,8,5,1,2]，变成树就是：\n\n\n\n\n\n\n\n\n\n     7\n     /   \\\n     3     8\n     / \\   /\n     5   1 2\n\nWhat is the 大根堆  ?还是以上面那个数组为例，数组内部最大的值是8，然鹅目前堆顶（Array[0]）是7，所以这并不是一个大根堆。\n大根堆：每个结点的值都大于或等于其左右孩子结点的值\n$So$，上面那个数组要是一个大根堆就必须是:\n\n\n\n\n\n\n\n\n\n     8\n     /   \\\n     5     7\n     / \\   /\n     3   1 2\n     那么，Array从[7,3,8,5,1,2] 变成了 [8,5,7,3,1,2]，你看，我并木有定义一个二叉树，只是交换了数组内部的顺序。\n\n一般来说我们会使得堆顶的元素出堆，这跟队列是一样的，所以这个结构也被叫做优先队列。\n需要补充的几个概念：在完全二叉树中,对于非根节点x都有\n\n父级值在Array数组的下标为： Math.floor(x/2) 或者使用位运算 x &gt;&gt; 2\n左子级值在Array数组的下标为：2x\n右子级值在Array数组的下标为： 2x + 1\n\n还记得我们的堆其实是一个数组么，如果x=0，那么以上三个性质都不会生效，所以我们一般初始化数组的时候使用：arr = [0]，这样所有实际元素的index都会大于1，完美适用以上三条性质。\nShow me your codeclass Heap &#123;\n\tconstructor(compare) &#123;\n\t\tthis.list = [0]; //数组，存放数据\n\t\tthis.compare = typeof compare === 'function' ? compare : this.defaultCompare;\n\t&#125;\n\t// 下方定义左子树，右子树和根节点的获取方式\n\tleft(x) &#123;\n\t\treturn 2 * x;\n\t&#125;\n\tright(x) &#123;\n\t\treturn 2 * x + 1;\n\t&#125;\n\tparent(x) &#123;\n\t\treturn x >> 1;\n\t&#125;\n\n\t//控制堆升序排列还是降序排列\n\tdefaultCompare(a, b) &#123;\n\t\treturn a > b;\n\t&#125;\n\t// 交换x和y对应位置的值\n\tswap(x, y) &#123;\n\t\tconst t = this.list[x];\n\t\tthis.list[x] = this.list[y];\n\t\tthis.list[y] = t;\n\t&#125;\n\t//是否为空\n\tisEmpty() &#123;\n\t\treturn this.list.length === 1;\n\t&#125;\n\t// 数组长度\n\tgetSize() &#123;\n\t\treturn this.list.length - 1;\n\t&#125;\n\t// 最大值\n\ttop() &#123;\n\t\treturn this.list[1];\n\t&#125;\n\t// 删除最大值\n\tpop() &#123;\n\t\tconst &#123; list &#125; = this;\n\t\tif (list.length === 0) return null;\n\t\t// 交换最大值到最后一位，方便pop\n\t\tthis.swap(1, list.length - 1);\n\t\t// 取出最大值\n\t\tconst top = list.pop();\n\t\t// 让第一位重新变成最大值\n\t\tthis.down(1);\n\t\treturn top;\n\t&#125;\n\t// 这个函数使得第一位重新变成最大值\n\tdown(k) &#123;\n\t\tconst &#123; list, left, right, compare &#125; = this;\n\t\tconst size = this.getSize();\n\t\twhile (left(k) &lt;= size) &#123;\n\t\t\t// 下面两行就是把_left取了左子树和右子树偏大的那个\n\t\t\tlet _left = left(k);\n\t\t\tif (right(k) &lt;= size &amp;&amp; compare(list[right(k)], list[_left])) &#123;\n\t\t\t\t_left = right(k);\n\t\t\t&#125;\n\t\t\t// 如果根节点比_left大，就跳出\n\t\t\tif (compare(list[k], list[_left])) return;\n\t\t\t// 否则就交换两个节点，并把k指向_left\n\t\t\tthis.swap(k, _left);\n\t\t\tk = _left;\n\t\t&#125;\n\t&#125;\n\n\t//添加值\n\tpush(val) &#123;\n\t\t// 新增数据，向堆尾添加\n\t\tthis.list.push(val);\n\n\t\tthis.up(this.list.length - 1);\n\t&#125;\n\tup(k) &#123;\n\t\tconst &#123; list, parent, compare &#125; = this;\n\t\t// 第k个元素和它的根节点比较\n\t\twhile (k > 1 &amp;&amp; compare(list[k], list[parent(k)])) &#123;\n\t\t\t// 交换x和y对应位置的值\n\t\t\tthis.swap(parent(k), k);\n\t\t\tk = parent(k);\n\t\t&#125;\n\t&#125;\n&#125;\n万恶的力扣真题OK，你已经学会了如何构建一个大根堆，让我们来看一下这万恶的周赛第3题，建堆代码如上，所以我省略。\n\nvar minGroups = function(intervals) &#123;\n    // 小根堆\n    let tmp = new Heap((a,b)=>a&lt;b);\n    intervals.sort((a,b)=> a[0]-b[0] || a[1] - b[1]);\n    for(let arr of intervals)&#123;\n        const [x,y] = arr;\n        if(tmp.list.length == 1 || tmp.list[1] >= x)&#123;\n            tmp.push(y);\n        &#125;else&#123;\n            tmp.pop();\n            tmp.push(y);\n        &#125;\n    &#125;\n    return tmp.getSize();\n&#125;;\n是不是很简单呀，短短十几行代码（不算建堆的80来行代码），所以JS为什么没有内置的数据结构库，连C++都是调的heapq函数！！！！\n所以以下来一个我的老本行Python版本\nfrom heapq import *\ndef minGroups(self, intervals: List[List[int]]) -> int:\n    tmp = []\n    intervals.sort()\n    for x, y in intervals:\n        if len(tmp) == 0 or tmp[0] >= x:\n            heappush(tmp, y)\n        else:\n            heappop(tmp)\n            heappush(tmp, y)\n    return len(tmp)\n万恶的Python仗着自己库多就沾沾自喜，殊不知我们Javascript多写了80多行代码，时间快了40ms，达到了质的飞跃,但是为什么多用了30MB的空间？\n\n\n\n\n\n\n\n\n\n\n\n欢迎关注这个摸鱼更新的公众号\n\n","slug":"优先队列","date":"2022-09-12T10:00:00.000Z","categories_index":"","tags_index":"","author_index":"风离"},{"id":"3f87f7f4d499de2354cd9a59a4ce9c6b","title":"字节跳动2022年9月模拟笔试","content":"9月排名赛代码总结第一题：炮弹传感器2为了研究炮弹的射击轨迹，研究人员在炮弹上安装了一个高精度的高度传感器，每隔一小段时间记录一下当前的海拔高度。研究人员需要找到一个快速的算法，可以方便的找到曾经飞到过某一个高度的炮弹数据。\n输入描述:第一行为正整数m，表示有m组测试用例，其中1&lt;&#x3D;m &lt;&#x3D;10000接下来2m行，每2行代表一组测试用例\n其中，前一行为正整数n, k，分别代表数据传感器的数据条数和目标高度，其中1&lt;&#x3D;n &lt;&#x3D; 10000，1 &lt;&#x3D;k &lt;&#x3D;10000o\n后一行有n个正整数，编号为[0,… , n-1]，代表数据传感器的高度数据，先升后降，而且只有可能在最高点存在相邻数据高度一样的情况，其余地方不存在相邻数据高度一致的情况，其中每个数据均满足[0,100000]\n输出描述:每行输出一个炮弹是否飞到过当前高度，如果是，打标输出在采样数据的第几个到第几个数据是在该高度及以上\n示例输入5\n9 4\n1 2 3 4 5 5 4 3 2\n9 14\n1 2 3 4 5 5 4 3 2\n11 7\n1 2 3 4 5 6 7 5 4 3 2\n1 14\n1\n1 1\n1\n输出true 3 6\nfalse\ntrue 6 6\nFalse\ntrue 0 0\n\n解法\n\n思路：双指针，两端分别在0和n-1分别开始，直到高度到达k。\n\n正常情况是i和j分别在两边，即i &lt;= j，输出true i j；\n\n若i &gt; j，则没有到达指定高度，输出false。\n\n\n\n\nconst readline &#x3D; require(&#39;readline&#39;);\nconst rl &#x3D; readline.createInterface(&#123;\n        input: process.stdin,\n        output: process.stdout,\n&#125;);\nlet cur_line &#x3D; 0;\nlet k;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n        if (cur_line &#x3D;&#x3D; 0) &#123;\n                cur_line +&#x3D; 1;\n                return;\n        &#125;\n        if (cur_line % 2 !&#x3D;&#x3D; 0) &#123;\n                &#x2F;&#x2F; 奇数行得到k\n                k &#x3D; parseInt(line.split(&#39; &#39;)[1]);\n        &#125; else &#123;\n                let arr &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n                console.log(&#39;******答案输出：&#39;, findheight(arr, k));\n        &#125;\n        cur_line +&#x3D; 1;\n&#125;);\n\nfunction findheight(arr, k) &#123;\n        let i &#x3D; 0,\n                n &#x3D; arr.length,\n                j &#x3D; n - 1;\n        while (i &lt; n &amp;&amp; arr[i] &lt; k) i++;\n        while (i &gt; 0 &amp;&amp; arr[j] &lt; k) j--;\n        if (i &gt; j) &#123;\n                return false;\n        &#125; else &#123;\n                return &#96;true $&#123;i&#125; $&#123;j&#125;&#96;;\n        &#125;\n&#125;\n\n第二题：取餐次序计算防疫期间，为了降低传播风险，公司食堂启用线上订餐、通知取餐的策略，公司员工需要在线上提交就餐需求，并填写对取餐时间安排的容忍度（1-9个等级)，容忍度越低表示越想拿到饭，会被更早通知取餐，就餐需求提交后会按照提交顺序生成订单(订单号从1开始递增)，通知取餐的工作人员的工作模式如下:拿到按顺序生成的订单列表后开始翻阅，如果某订单容忍度在剩余订单中是最低的，就通知该订单的下单员工取餐，否则将订单移至列表尾部，已知某日午餐的订单列表和某个订单号，计算该订单会被安排在第几位取餐。\n输入描述:第一行两个整数，分别是订单总数m (m&lt;&#x3D;1000)、订单号n(从1开始)\n第二行是订单列表对应的容忍度列表\n输出描述:输出一个整数表示订单号n的实际取餐次序\n示例14 3\n1 2 3 4\n输出3\n说明总共4个订单，自己的订单号是3（从1开始），按订单号排序的4个订单的容忍度分别是1、2、3、4，那么自己会被安排在第3位取餐。\n示例27 3\n8 7 8 9 1 2 8\n输出4\n说明总共7个订单，自己的订单号是3(从1开始)，按订单号排序的4个订单的容忍度分别是8、7、8、9、1、2、8，那么自己会被安排在第4位取餐\n第一位取餐的容忍度是1\n第二位取餐的容忍度是2\n第三位取餐的容忍度是7\n第四位取餐的容忍度是8，即自己\n解法：思路：优先队列，但是JS没有内置的优先队列库，我不想自己写，而且我实在看不懂C++版的答案，所以下面用了sort函数直接排了个序，当作优先队列，然后维护一个指针myTurnIndex，保证可以知道自己的订单号到底在哪个位置，测了几组数据，应该是和答案一致的。\nconst readline &#x3D; require(&#39;readline&#39;);\nconst rl &#x3D; readline.createInterface(&#123;\n    input: process.stdin,\n    output: process.stdout,\n&#125;);\nlet cur_line &#x3D; 0;\nlet k;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n    if (cur_line &#x3D;&#x3D;&#x3D; 0) &#123;\n        k &#x3D; parseInt(line.split(&#39; &#39;)[1]) - 1;\n        cur_line +&#x3D; 1;\n    &#125; else if (cur_line &#x3D;&#x3D;&#x3D; 1) &#123;\n        let arr &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        &#x2F;&#x2F; console.log(arr, k);\n        console.log(&#39;******答案输出：&#39;, main(arr, k));\n    &#125;\n&#125;);\n\nfunction main(arr, k) &#123;\n    let myTurnIndex &#x3D; k,\n        myTurn &#x3D; arr[k],\n        count &#x3D; 1;\n    heapq &#x3D; [];\n    arr.forEach(element &#x3D;&gt; &#123;\n        heapq.push(element);\n    &#125;);\n    heapq.sort((a, b) &#x3D;&gt; a - b);\n    console.log(heapq);\n    console.log(arr);\n    while (true) &#123;\n        let tmp &#x3D; arr.shift();\n        &#x2F;&#x2F; console.log(&#96;arr:$&#123;arr&#125;，tmp:$&#123;tmp&#125;，myTurnIndex：$&#123;myTurnIndex&#125;&#96;);\n        if (tmp &#x3D;&#x3D;&#x3D; heapq[0] &amp;&amp; tmp &#x3D;&#x3D;&#x3D; myTurn &amp;&amp; myTurnIndex &#x3D;&#x3D;&#x3D; 0) &#123;\n            return count;\n        &#125;\n        if (tmp &#x3D;&#x3D;&#x3D; heapq[0]) &#123;\n            &#x2F;&#x2F; console.log(&#39;-----&#39;);\n            count +&#x3D; 1;\n            heapq.shift();\n            myTurnIndex--;\n            continue;\n        &#125;\n        &#x2F;&#x2F; 这里开始就是不符合最小容忍度的了\n        &#x2F;&#x2F; 如果是自己\n        if (tmp &#x3D;&#x3D;&#x3D; myTurn &amp;&amp; myTurnIndex &#x3D;&#x3D;&#x3D; 0) &#123;\n            arr.push(tmp);\n            myTurnIndex &#x3D; heapq.length - 1;\n        &#125; else &#123;\n            &#x2F;&#x2F; 如果不是自己\n            arr.push(tmp);\n            myTurnIndex--;\n        &#125;\n    &#125;\n&#125;","slug":"字节跳动九月模拟笔试","date":"2022-09-07T13:57:00.000Z","categories_index":"","tags_index":"","author_index":"风离"}]