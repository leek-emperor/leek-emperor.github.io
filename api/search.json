[{"id":"7de360a3c5a4628d6c3bdcf00d588e7c","title":"一个倒霉蛋的周赛日记","content":"大家好，这里是丹星，今天作为重回周赛的第二周，终于创下了历史记录——拿满18分。但是因为JS在力扣的奇怪Bug，我第四道题被卡在84％，所以面板上还是三道题12分。\n不否认本周的周赛题目确实比较简单，第一名的大佬在9分钟内就完成了四道题，那时候我刚写完第二题。\n\n第一题 最小偶倍数给你一个正整数 n ，返回 2 和 n 的最小公倍数（正整数）。\n\n\n\n\n\n\n\n\n\n输入：n &#x3D; 5\n输出：10\n解释：5 和 2 的最小公倍数是 10 。\n一道侮辱智商的题目，不解释\nvar smallestEvenMultiple = function(n) &#123;\n    if(n % 2 == 0)&#123;\n        return n\n    &#125;else&#123;\n        return n * 2;\n    &#125;\n&#125;;\n\n第二题 最长的字母序连续子字符串的长度字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 “abcdefghijklmnopqrstuvwxyz” 的任意子字符串都是 字母序连续字符串 。\n例如，”abc” 是一个字母序连续字符串，而 “acb” 和 “za” 不是。给你一个仅由小写英文字母组成的字符串 s ，返回其 最长 的 字母序连续子字符串 的长度。\n\n\n\n\n\n\n\n\n\n输入：s &#x3D; “abacaba”\n输出：2\n解释：共有 4 个不同的字母序连续子字符串 “a”、”b”、”c” 和 “ab” 。“ab” 是最长的字母序连续子字符串。\n这个也挺简单的，只需要判断第i个字符串和第i-1个字符串是否是连续的就行（根据ASCII码）\nvar longestContinuousSubstring = function(s) &#123;\n    let ans = 1,\n        tmp = 1;\n    for(let i = 1; i &lt; s.length; i++)&#123;\n        if(s[i].charCodeAt() - s[i - 1].charCodeAt() == 1)&#123;\n            tmp++;\n        &#125;else&#123;\n            ans = Math.max(tmp, ans);\n            tmp = 1;\n        &#125;\n    &#125;\n    return Math.max(ans,tmp);\n&#125;;\n第三题 反转二叉树的奇数层给你一棵完美二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。\n\n例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。\n\n反转后，返回树的根节点。\n完美二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。\n节点的 层数 等于该节点到根节点之间的边数。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入：root &#x3D; [2,3,5,8,13,21,34]\n输出：[2,5,3,8,13,21,34]\n解释：\n这棵树只有一个奇数层。\n在第 1 层的节点分别是 3、5 ，反转后为 5、3 。\n一看到树当然就要想到递归或者迭代啦，或者DFS和BFS。这道题我用的BFS，但是应该还有更好的解法，毕竟我同时用了三个栈。\nvar reverseOddLevels = function(root) &#123;\n    let n = 0,\n        stack = [root],\n        node_stack = [],\n        val_stack = [],\n        flag = 1;\n    while(flag)&#123;\n        if(n % 2 == 0)&#123;\n            // 因为是完美二叉树，所以只要出现节点为null\n            // 就说明到了最后一层，直接跳出\n            if(stack[0].left == null)&#123;\n                flag = 0;\n                break;\n            &#125;\n            while(stack.length)&#123;\n                const node = stack.shift();\n                node_stack.push(node.left, node.right);\n                val_stack.push(node.left.val, node.right.val);\n            &#125;\n            while(val_stack.length)&#123;\n                const node = node_stack.shift(),\n                      val = val_stack.pop();\n                node.val = val;\n                stack.push(node);\n            &#125;\n            n++;\n        &#125;else&#123;\n            // 奇数层，已经完成了逆转，现在stack是满的，\n            // node_stack和val_stack为空，\n            // 我们要把下一个偶数层的node全部存到stack里面，\n            // 也就是替换掉stack里面的节点\n            if(stack[0].left == null)&#123;\n                flag = 0;\n                break;\n            &#125;\n            let currentLen = stack.length;\n            for(let i = 0; i &lt; currentLen; i++)&#123;\n                let tmp = stack.shift();\n                stack.push(tmp.left,tmp.right);\n            &#125;\n            n++;\n        &#125;\n    &#125;\n    return root;\n&#125;;\n第四题 字符串的前缀分数和给你一个长度为 n 的数组 words ，该数组由 非空 字符串组成。\n定义字符串 word 的 分数 等于以 word 作为 前缀 的 words[i] 的数目。\n\n例如，如果 words &#x3D; [“a”, “ab”, “abc”, “cab”] ，那么 “ab” 的分数是 2 ，因为 “ab” 是 “ab” 和 “abc” 的一个前缀。\n\n返回一个长度为 n 的数组 answer ，其中 answer[i] 是 words[i] 的每个非空前缀的分数 总和 。\n注意：字符串视作它自身的一个前缀。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入：words &#x3D; [“abc”,”ab”,”bc”,”b”]\n输出：[5,4,3,2]\n解释：对应每个字符串的答案如下：\n\n“abc” 有 3 个前缀：”a”、”ab” 和 “abc” 。\n2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” ，1 个字符串的前缀为 “abc” 。\n\n总计 answer[0] &#x3D; 2 + 2 + 1 &#x3D; 5 。\n\n“ab” 有 2 个前缀：”a” 和 “ab” 。\n2 个字符串的前缀为 “a” ，2 个字符串的前缀为 “ab” 。\n\n总计 answer[1] &#x3D; 2 + 2 &#x3D; 4 。\n\n“bc” 有 2 个前缀：”b” 和 “bc” 。\n2 个字符串的前缀为 “b” ，1 个字符串的前缀为 “bc” 。\n\n总计 answer[2] &#x3D; 2 + 1 &#x3D; 3 。\n\n“b” 有 1 个前缀：”b”。\n2 个字符串的前缀为 “b” 。\n\n总计 answer[3] &#x3D; 2 。\n这道题最正统的解法应该是字典树，但是——我不会。不过我还是想出了另外一种更加通俗易懂的解法。\n\n首先，遍历每一个单词，用哈希表存储所有的前缀词。如果前缀词存在，则计数+1；如果不存在则计数为1.\n在存储哈希表时，维护一个栈，这个栈里面存储对应单词的所有前缀，所以这个栈存的元素也是列表\n最后，遍历栈，根据哈希表可以查找到对应单词所有前缀和的计数，相加，得到对应位置的值。Javascript版：var sumPrefixScores = function (words) &#123;\n\tif (words.length == 1) &#123;\n\t\treturn [words[0].length];\n\t&#125;\n\tlet map = &#123;&#125;,\n\t\tans = [];\n\tfor (let word of words) &#123;\n\t\tlet right = 1,\n\t\t\ttmp = [];\n\t\twhile (right &lt;= word.length) &#123;\n\t\t\tlet s = word.slice(0, right);\n\t\t\tif (map[s] == undefined) &#123;\n\t\t\t\tmap[s] = 1;\n\t\t\t&#125; else &#123;\n\t\t\t\tmap[s]++;\n\t\t\t&#125;\n\t\t\ttmp.push(s);\n\t\t\tright++;\n\t\t&#125;\n\t\tans.push(tmp);\n\t&#125;\n\tlet res = [];\n\tfor (let arr of ans) &#123;\n\t\tlet sum = 0;\n\t\tarr.forEach(val => &#123;\n\t\t\tsum += map[val];\n\t\t&#125;);\n\t\tres.push(sum);\n\t&#125;\n\treturn res;\n&#125;;\n这个解法在Leetcode第32个用例中爆出莫名错误，但是在本地运行无碍。比赛中我一度认为是这个方法没有考虑到一些特殊情况，但是在周赛结束后，我发现一位前排大佬的Python版本代码和我的思路一致。def sumPrefixScores(words):\n    count =  defaultdict(int)\n    for word in words:\n        m = len(word)\n        for i in range(1, m+1):\n            count[word[:i]] += 1\n            \n    ans = []\n    for word in words:\n        m = len(word)\n        cur = 0\n        for i in range(1, m+1):\n            cur += count[word[:i]]\n        ans.append(cur)\n    return ans\n\n我不管！！！这周周赛我就是满分，这不是超时，我本地代码跑那个例子也只用了2s。\n力扣还我血汗分！！！\n\n\n\n\n\n\n\n\n\n\n欢迎关注这个摸鱼更新的公众号\n\n","slug":"一个倒霉蛋的周赛日记","date":"2022-09-18T10:00:00.000Z","categories_index":"数据结构与算法","tags_index":"数据结构,周赛,二叉树,哈希表","author_index":"风离"},{"id":"ccd980cab5c75bdd94e2c8b8c13252bb","title":"数据结构（四）优先队列/大小根堆","content":"大家好，这里是丹星，又来更新数据结构啦，今天也是老朋友啦，因为之前的几篇文章都提到了它：优先队列，又叫小&#x2F;大根堆。为什么这么快更新呢，因为昨天力扣周赛遇到这个被打爆啦，因为发现了之前总是用sort模拟小根堆也不是办法呀，还是得自己会写。\nWhat is the 堆  ?其实堆不是一个需要我们从头开始定义的一个数据结构，它的本质是用数组去模拟完全二叉树。为什么说是用数组去模拟树呢，因为它并不是真的要去定一个二叉树类，而是本质上还是对数组进行操作。\n二叉树大家都不陌生，那我们讲下以下两个定义。如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树，如：\n\n如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n\n那么一个数组，就可以被看作是一个完全二叉树，也就是一个堆，比如Array &#x3D; array &#x3D; [7,3,8,5,1,2]，变成树就是：\n\n\n\n\n\n\n\n\n\n     7\n     /   \\\n     3     8\n     / \\   /\n     5   1 2\n\nWhat is the 大根堆  ?还是以上面那个数组为例，数组内部最大的值是8，然鹅目前堆顶（Array[0]）是7，所以这并不是一个大根堆。\n大根堆：每个结点的值都大于或等于其左右孩子结点的值\n$So$，上面那个数组要是一个大根堆就必须是:\n\n\n\n\n\n\n\n\n\n     8\n     /   \\\n     5     7\n     / \\   /\n     3   1 2\n     那么，Array从[7,3,8,5,1,2] 变成了 [8,5,7,3,1,2]，你看，我并木有定义一个二叉树，只是交换了数组内部的顺序。\n\n一般来说我们会使得堆顶的元素出堆，这跟队列是一样的，所以这个结构也被叫做优先队列。\n需要补充的几个概念：在完全二叉树中,对于非根节点x都有\n\n父级值在Array数组的下标为： Math.floor(x/2) 或者使用位运算 x &gt;&gt; 2\n左子级值在Array数组的下标为：2x\n右子级值在Array数组的下标为： 2x + 1\n\n还记得我们的堆其实是一个数组么，如果x=0，那么以上三个性质都不会生效，所以我们一般初始化数组的时候使用：arr = [0]，这样所有实际元素的index都会大于1，完美适用以上三条性质。\nShow me your codeclass Heap &#123;\n\tconstructor(compare) &#123;\n\t\tthis.list = [0]; //数组，存放数据\n\t\tthis.compare = typeof compare === 'function' ? compare : this.defaultCompare;\n\t&#125;\n\t// 下方定义左子树，右子树和根节点的获取方式\n\tleft(x) &#123;\n\t\treturn 2 * x;\n\t&#125;\n\tright(x) &#123;\n\t\treturn 2 * x + 1;\n\t&#125;\n\tparent(x) &#123;\n\t\treturn x >> 1;\n\t&#125;\n\n\t//控制堆升序排列还是降序排列\n\tdefaultCompare(a, b) &#123;\n\t\treturn a > b;\n\t&#125;\n\t// 交换x和y对应位置的值\n\tswap(x, y) &#123;\n\t\tconst t = this.list[x];\n\t\tthis.list[x] = this.list[y];\n\t\tthis.list[y] = t;\n\t&#125;\n\t//是否为空\n\tisEmpty() &#123;\n\t\treturn this.list.length === 1;\n\t&#125;\n\t// 数组长度\n\tgetSize() &#123;\n\t\treturn this.list.length - 1;\n\t&#125;\n\t// 最大值\n\ttop() &#123;\n\t\treturn this.list[1];\n\t&#125;\n\t// 删除最大值\n\tpop() &#123;\n\t\tconst &#123; list &#125; = this;\n\t\tif (list.length === 0) return null;\n\t\t// 交换最大值到最后一位，方便pop\n\t\tthis.swap(1, list.length - 1);\n\t\t// 取出最大值\n\t\tconst top = list.pop();\n\t\t// 让第一位重新变成最大值\n\t\tthis.down(1);\n\t\treturn top;\n\t&#125;\n\t// 这个函数使得第一位重新变成最大值\n\tdown(k) &#123;\n\t\tconst &#123; list, left, right, compare &#125; = this;\n\t\tconst size = this.getSize();\n\t\twhile (left(k) &lt;= size) &#123;\n\t\t\t// 下面两行就是把_left取了左子树和右子树偏大的那个\n\t\t\tlet _left = left(k);\n\t\t\tif (right(k) &lt;= size &amp;&amp; compare(list[right(k)], list[_left])) &#123;\n\t\t\t\t_left = right(k);\n\t\t\t&#125;\n\t\t\t// 如果根节点比_left大，就跳出\n\t\t\tif (compare(list[k], list[_left])) return;\n\t\t\t// 否则就交换两个节点，并把k指向_left\n\t\t\tthis.swap(k, _left);\n\t\t\tk = _left;\n\t\t&#125;\n\t&#125;\n\n\t//添加值\n\tpush(val) &#123;\n\t\t// 新增数据，向堆尾添加\n\t\tthis.list.push(val);\n\n\t\tthis.up(this.list.length - 1);\n\t&#125;\n\tup(k) &#123;\n\t\tconst &#123; list, parent, compare &#125; = this;\n\t\t// 第k个元素和它的根节点比较\n\t\twhile (k > 1 &amp;&amp; compare(list[k], list[parent(k)])) &#123;\n\t\t\t// 交换x和y对应位置的值\n\t\t\tthis.swap(parent(k), k);\n\t\t\tk = parent(k);\n\t\t&#125;\n\t&#125;\n&#125;\n万恶的力扣真题OK，你已经学会了如何构建一个大根堆，让我们来看一下这万恶的周赛第3题，建堆代码如上，所以我省略。\n\nvar minGroups = function(intervals) &#123;\n    // 小根堆\n    let tmp = new Heap((a,b)=>a&lt;b);\n    intervals.sort((a,b)=> a[0]-b[0] || a[1] - b[1]);\n    for(let arr of intervals)&#123;\n        const [x,y] = arr;\n        if(tmp.list.length == 1 || tmp.list[1] >= x)&#123;\n            tmp.push(y);\n        &#125;else&#123;\n            tmp.pop();\n            tmp.push(y);\n        &#125;\n    &#125;\n    return tmp.getSize();\n&#125;;\n是不是很简单呀，短短十几行代码（不算建堆的80来行代码），所以JS为什么没有内置的数据结构库，连C++都是调的heapq函数！！！！\n所以以下来一个我的老本行Python版本\nfrom heapq import *\ndef minGroups(self, intervals: List[List[int]]) -> int:\n    tmp = []\n    intervals.sort()\n    for x, y in intervals:\n        if len(tmp) == 0 or tmp[0] >= x:\n            heappush(tmp, y)\n        else:\n            heappop(tmp)\n            heappush(tmp, y)\n    return len(tmp)\n万恶的Python仗着自己库多就沾沾自喜，殊不知我们Javascript多写了80多行代码，时间快了40ms，达到了质的飞跃,但是为什么多用了30MB的空间？\n\n\n\n\n\n\n\n\n\n\n\n欢迎关注这个摸鱼更新的公众号\n\n","slug":"优先队列","date":"2022-09-12T10:00:00.000Z","categories_index":"数据结构与算法","tags_index":"数据结构,优先队列","author_index":"风离"},{"id":"8ff685f8218119a3e3b228fe1d1d8ae5","title":"字节跳动2022年9月模拟笔试（上）","content":"9月排名赛代码总结第一题：炮弹传感器2为了研究炮弹的射击轨迹，研究人员在炮弹上安装了一个高精度的高度传感器，每隔一小段时间记录一下当前的海拔高度。研究人员需要找到一个快速的算法，可以方便的找到曾经飞到过某一个高度的炮弹数据。\n输入描述:第一行为正整数m，表示有m组测试用例，其中1&lt;&#x3D;m &lt;&#x3D;10000接下来2m行，每2行代表一组测试用例\n其中，前一行为正整数n, k，分别代表数据传感器的数据条数和目标高度，其中1&lt;&#x3D;n &lt;&#x3D; 10000，1 &lt;&#x3D;k &lt;&#x3D;10000o\n后一行有n个正整数，编号为[0,… , n-1]，代表数据传感器的高度数据，先升后降，而且只有可能在最高点存在相邻数据高度一样的情况，其余地方不存在相邻数据高度一致的情况，其中每个数据均满足[0,100000]\n输出描述:每行输出一个炮弹是否飞到过当前高度，如果是，打标输出在采样数据的第几个到第几个数据是在该高度及以上\n示例输入5\n9 4\n1 2 3 4 5 5 4 3 2\n9 14\n1 2 3 4 5 5 4 3 2\n11 7\n1 2 3 4 5 6 7 5 4 3 2\n1 14\n1\n1 1\n1\n输出true 3 6\nfalse\ntrue 6 6\nFalse\ntrue 0 0\n\n解法\n\n思路：双指针，两端分别在0和n-1分别开始，直到高度到达k。\n\n正常情况是i和j分别在两边，即i &lt;= j，输出true i j；\n\n若i &gt; j，则没有到达指定高度，输出false。\n\n\n\n\nconst readline &#x3D; require(&#39;readline&#39;);\nconst rl &#x3D; readline.createInterface(&#123;\n        input: process.stdin,\n        output: process.stdout,\n&#125;);\nlet cur_line &#x3D; 0;\nlet k;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n        if (cur_line &#x3D;&#x3D; 0) &#123;\n                cur_line +&#x3D; 1;\n                return;\n        &#125;\n        if (cur_line % 2 !&#x3D;&#x3D; 0) &#123;\n                &#x2F;&#x2F; 奇数行得到k\n                k &#x3D; parseInt(line.split(&#39; &#39;)[1]);\n        &#125; else &#123;\n                let arr &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n                console.log(&#39;******答案输出：&#39;, findheight(arr, k));\n        &#125;\n        cur_line +&#x3D; 1;\n&#125;);\n\nfunction findheight(arr, k) &#123;\n        let i &#x3D; 0,\n                n &#x3D; arr.length,\n                j &#x3D; n - 1;\n        while (i &lt; n &amp;&amp; arr[i] &lt; k) i++;\n        while (i &gt; 0 &amp;&amp; arr[j] &lt; k) j--;\n        if (i &gt; j) &#123;\n                return false;\n        &#125; else &#123;\n                return &#96;true $&#123;i&#125; $&#123;j&#125;&#96;;\n        &#125;\n&#125;\n\n第二题：取餐次序计算防疫期间，为了降低传播风险，公司食堂启用线上订餐、通知取餐的策略，公司员工需要在线上提交就餐需求，并填写对取餐时间安排的容忍度（1-9个等级)，容忍度越低表示越想拿到饭，会被更早通知取餐，就餐需求提交后会按照提交顺序生成订单(订单号从1开始递增)，通知取餐的工作人员的工作模式如下:拿到按顺序生成的订单列表后开始翻阅，如果某订单容忍度在剩余订单中是最低的，就通知该订单的下单员工取餐，否则将订单移至列表尾部，已知某日午餐的订单列表和某个订单号，计算该订单会被安排在第几位取餐。\n输入描述:第一行两个整数，分别是订单总数m (m&lt;&#x3D;1000)、订单号n(从1开始)\n第二行是订单列表对应的容忍度列表\n输出描述:输出一个整数表示订单号n的实际取餐次序\n示例14 3\n1 2 3 4\n输出3\n说明总共4个订单，自己的订单号是3（从1开始），按订单号排序的4个订单的容忍度分别是1、2、3、4，那么自己会被安排在第3位取餐。\n示例27 3\n8 7 8 9 1 2 8\n输出4\n说明总共7个订单，自己的订单号是3(从1开始)，按订单号排序的4个订单的容忍度分别是8、7、8、9、1、2、8，那么自己会被安排在第4位取餐\n第一位取餐的容忍度是1\n第二位取餐的容忍度是2\n第三位取餐的容忍度是7\n第四位取餐的容忍度是8，即自己\n解法：思路：优先队列，但是JS没有内置的优先队列库，我不想自己写，而且我实在看不懂C++版的答案，所以下面用了sort函数直接排了个序，当作优先队列，然后维护一个指针myTurnIndex，保证可以知道自己的订单号到底在哪个位置，测了几组数据，应该是和答案一致的。\nconst readline &#x3D; require(&#39;readline&#39;);\nconst rl &#x3D; readline.createInterface(&#123;\n    input: process.stdin,\n    output: process.stdout,\n&#125;);\nlet cur_line &#x3D; 0;\nlet k;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n    if (cur_line &#x3D;&#x3D;&#x3D; 0) &#123;\n        k &#x3D; parseInt(line.split(&#39; &#39;)[1]) - 1;\n        cur_line +&#x3D; 1;\n    &#125; else if (cur_line &#x3D;&#x3D;&#x3D; 1) &#123;\n        let arr &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        &#x2F;&#x2F; console.log(arr, k);\n        console.log(&#39;******答案输出：&#39;, main(arr, k));\n    &#125;\n&#125;);\n\nfunction main(arr, k) &#123;\n    let myTurnIndex &#x3D; k,\n        myTurn &#x3D; arr[k],\n        count &#x3D; 1;\n    heapq &#x3D; [];\n    arr.forEach(element &#x3D;&gt; &#123;\n        heapq.push(element);\n    &#125;);\n    heapq.sort((a, b) &#x3D;&gt; a - b);\n    console.log(heapq);\n    console.log(arr);\n    while (true) &#123;\n        let tmp &#x3D; arr.shift();\n        &#x2F;&#x2F; console.log(&#96;arr:$&#123;arr&#125;，tmp:$&#123;tmp&#125;，myTurnIndex：$&#123;myTurnIndex&#125;&#96;);\n        if (tmp &#x3D;&#x3D;&#x3D; heapq[0] &amp;&amp; tmp &#x3D;&#x3D;&#x3D; myTurn &amp;&amp; myTurnIndex &#x3D;&#x3D;&#x3D; 0) &#123;\n            return count;\n        &#125;\n        if (tmp &#x3D;&#x3D;&#x3D; heapq[0]) &#123;\n            &#x2F;&#x2F; console.log(&#39;-----&#39;);\n            count +&#x3D; 1;\n            heapq.shift();\n            myTurnIndex--;\n            continue;\n        &#125;\n        &#x2F;&#x2F; 这里开始就是不符合最小容忍度的了\n        &#x2F;&#x2F; 如果是自己\n        if (tmp &#x3D;&#x3D;&#x3D; myTurn &amp;&amp; myTurnIndex &#x3D;&#x3D;&#x3D; 0) &#123;\n            arr.push(tmp);\n            myTurnIndex &#x3D; heapq.length - 1;\n        &#125; else &#123;\n            &#x2F;&#x2F; 如果不是自己\n            arr.push(tmp);\n            myTurnIndex--;\n        &#125;\n    &#125;\n&#125;","slug":"字节跳动九月模拟笔试（上）","date":"2022-09-07T13:57:00.000Z","categories_index":"数据结构与算法","tags_index":"数据结构,优先队列,字节跳动,双指针","author_index":"风离"},{"id":"8ff685f8218119a3e3b228fe1d1d8ae5","title":"字节跳动2022年9月模拟笔试（上）","content":"第三题：数组游戏\n\n\n\n\n\n\n\n\n双休在家的凯凯真的是太无聊了，他准备和他家的猫玩一个游戏。\n凯凯在小黑板上写下一串有正有负的数列，猫咪从左到右，每碰到一个数，可以选择选取或者不选取。\n在选取过程中，要保证所有选取的数的和始终为非负。在这个限制条件下求最多可以选取多少个数。\n小猫咪表示“我太难了”\n你能帮帮它么?\n\n\n\n\n\n\n\n\n\n输入描述：会有多组询问\n首先输入一个数字接下来有组数据\n每组数据里，首先会有一个数，表示接下来这个数列的长度为\n然后接下来一行会有n个数字，从左到右表示题目所说的数列，每个数字\n输出描述：对于每一个提问，请依次输出最多可以选取多少个数\n备注：每个数字（）（\n\n\n\n\n\n\n\n\n\n示例输入2\n6\n4 -4 1 -3 -1 -3\n5\n1 2 3 4 5\n输出5\n5\n说明第一组数据：选取1，3，4，5，6个数；\n第二组数据，全部正数，那就全选。\n解法\n\n\n\n\n\n\n\n\n注意：必须从左到右选取，不能直接排序选！！！！！必须保证中间过程所选数之和非负！！！\n所以进行模拟，使用反悔贪心+优先队列（没错，又是他），规则如下：\n\n遇到正数或者零：直接选\n遇到负数\n选了之后sum &gt;&#x3D; 0，那么直接选，但是要存入优先队列（小根堆）中\n选了之后sum &lt; 0，那么在已经选择的负数中置换出一个最小的（前提是当前这个数是比已选负数的最小值要大的）\n\n注：因为JS没有内置的优先队列函数，我不想自己写一个，所以这里每次在队列加入元素都会使用一次sort函数，这样可以保证维护一个小根堆。\nconst rl &#x3D; readline.createInterface(&#123;\n    input: process.stdin,\n    output: process.stdout,\n&#125;);\nlet cur_line &#x3D; 0;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n    if (cur_line &lt; 2) &#123;\n        cur_line +&#x3D; 1;\n        return;\n    &#125;\n    if (cur_line % 2 &#x3D;&#x3D;&#x3D; 0) &#123;\n        let arr &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        &#x2F;&#x2F; console.log(arr, k);\n        console.log(&#39;******答案输出：&#39;, main(arr));\n    &#125;\n    cur_line++;\n&#125;);\n\nfunction main(arr) &#123;\n    let sum &#x3D; 0,\n        count &#x3D; 0,\n        q &#x3D; [];\n    while (arr.length) &#123;\n        let tmp &#x3D; arr.shift();\n        &#x2F;&#x2F; console.log(&#96;tmp:$&#123;tmp&#125;,q:$&#123;q&#125;,sum:$&#123;sum&#125;&#96;);\n        if (tmp &gt;&#x3D; 0) &#123;\n            sum +&#x3D; tmp;\n            count++;\n        &#125; else &#123;\n            if (sum + tmp &gt;&#x3D; 0) &#123;\n                sum +&#x3D; tmp;\n                q.push(tmp);\n                q.sort((a, b) &#x3D;&gt; a - b);\n                count++;\n            &#125; else &#123;\n                if (q.length !&#x3D; 0 &amp;&amp; q[0] &lt; tmp) &#123;\n                    sum &#x3D; sum - q.shift() + tmp;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return count;\n&#125;\n\n第四题：寻找对称的二叉树特定节点\n\n\n\n\n\n\n\n\n\n给定一颗二叉树，二叉树每个节点都有一个唯一的整数值代表节点，在遍历时，我们使用节点的整数值作为标记;结构对称，是指二叉树从根节点往下看，左右翻转一下，能够重合(不考虑节点内容比较，仅仅是结构)，我们就称这棵二叉树树结构对称\n输入:二叉树的节点个数N (0&lt;N&lt;60000)、前序和中序遍历结果，分别是第一行、第二行与第三行;各个节点整数值在1到60000之间\n输出︰判断这棵二叉树是否结构对称，若对称请输出最大值节点在树中对称节点的整数值，不对称请直接输出最大值节点的整数值\n\n\n\n\n\n\n\n\n\n\n输入描述二叉树的前序和中序遍历结果，以数组序列表示\n第一行为节点个数N (0&lt;N&lt;60000)前序和中序遍历结果，输入分别是第二行与第三行\n输出描述判断这棵二叉树是否结构对称，若对称请输出最大值节点在树中对称节点的整数值，不对称请直接输出最大值节点的整数值\n备注1.每个节点都有一个唯一的整数值代表节点（但比赛中实际数据似乎并不是的），结构对称不考虑节点内容数字大小比较，仅仅是结构\n2.根节点相对自己是对称的\n\n\n\n\n\n\n\n\n\n示例1输入3\n1 3 4\n3 1 4\n输出3\n说明这颗二叉树根是1，左右子节点分别是3和4，是结构对称的，4是最大值节点，其对称节点是3，所以最后输出为3。\n示例2输入5\n1 3 5 7 2\n5 3 1 2 7\n输出7\n说明这颗二叉树，节点7是数值最大的节点，但其节点2对称位置没有节点，二叉树不对称，所以输出为7。\n解法\n首先，根据前序遍历和中序遍历重建二叉树，这个具体怎么做看上篇公众号文章。\n然后，递归判断是否结构对称\n最后，如果对称，则输出最大值的对称节点；若不对称，则输出最大的节点值。\n\nconst &#123; func &#125; &#x3D; require(&#39;prop-types&#39;);\nconst readline &#x3D; require(&#39;readline&#39;);\nconst rl &#x3D; readline.createInterface(&#123;\n    input: process.stdin,\n    output: process.stdout,\n&#125;);\n\nlet cur_line &#x3D; 0,\n    preorder,\n    inorder;\nrl.on(&#39;line&#39;, line &#x3D;&gt; &#123;\n    if (cur_line &#x3D;&#x3D; 0) &#123;\n        cur_line++;\n        return;\n    &#125; else if (cur_line &#x3D;&#x3D; 1) &#123;\n        preorder &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        cur_line++;\n    &#125; else if (cur_line &#x3D;&#x3D; 2) &#123;\n        inorder &#x3D; line.split(&#39; &#39;).map(val &#x3D;&gt; parseInt(val));\n        console.log(main(preorder, inorder));\n    &#125;\n&#125;);\n\n&#x2F;&#x2F; 定义二叉树\nfunction TreeNode(val, left, right) &#123;\n    this.val &#x3D; val &#x3D;&#x3D;&#x3D; undefined ? 0 : val;\n    this.left &#x3D; left &#x3D;&#x3D;&#x3D; undefined ? null : left;\n    this.right &#x3D; right &#x3D;&#x3D;&#x3D; undefined ? null : right;\n&#125;\n\n&#x2F;&#x2F; 递归重建二叉树\nfunction buildTree(preorder, inorder) &#123;\n    if (preorder.length &#x3D;&#x3D;&#x3D; 0) return null;\n    let mid_index &#x3D; inorder.indexOf(preorder[0]);\n    let root &#x3D; new TreeNode(preorder[0]);\n    root.left &#x3D; buildTree(preorder.slice(1, mid_index + 1), inorder.slice(0, mid_index));\n    root.right &#x3D; buildTree(preorder.slice(mid_index + 1), inorder.slice(mid_index + 1));\n    return root;\n&#125;\n\n&#x2F;&#x2F; 递归检查树的结构是否对称（无需比较值）\nfunction check(left, right) &#123;\n    &#x2F;&#x2F; 如果都为null，那么对称，返回1\n    if (!left &amp;&amp; !right) return 1;\n    &#x2F;&#x2F; 如果只有一方为null，那不对称，返回0\n    if (!left || !right) return 0;\n    return check(left.left, right.right) &amp;&amp; check(left.right, right.left);\n&#125;\n\nfunction main(preorder, inorder) &#123;\n    &#x2F;* 这个查找对称二叉树的对称节点写在了主函数里面，\n        因为如果写在外面，那么必须传入max_value，然后在函数内部定义pair_val并返回\n        写在主函数内部的一个好处是，只要保证max_value和pair_val和findPair在同一作用域\n        那么findPair内部就会向外层自动寻找这两个值，类似于闭包。\n     *&#x2F;\n    function findPair(left, right) &#123;\n        if (!left || !right) return;\n        if (left.val &#x3D;&#x3D;&#x3D; max_value) &#123;\n            pair_val &#x3D; right.val;\n        &#125;\n        if (right.val &#x3D;&#x3D;&#x3D; max_value) &#123;\n            pair_val &#x3D; left.val;\n            return pair_val;\n        &#125;\n        &#x2F;&#x2F; 继续往下找\n        findPair(left.left, right.right);\n        findPair(left.right, right.left);\n    &#125;\n\n    &#x2F;&#x2F; 最大节点值对称点的值，先声明\n    &#x2F;&#x2F; 这里注意，必须在和findPair函数一级的作用域定义，\n    &#x2F;&#x2F; 因为如果在let在下方的if语句中定义，findPair会找不到pair_val\n    let pair_val;\n    &#x2F;&#x2F; 最大节点值\n    let max_value &#x3D; Math.max(...preorder);\n    let root &#x3D; buildTree(preorder, inorder);\n    let flag &#x3D; check(root.left, root.right);\n    if (flag) &#123;\n        &#x2F;&#x2F; 对称\n        findPair(root.left, root.right); &#x2F;&#x2F; 注意findPair的主要目的是修改pair_val，而非返回一个结果\n        return pair_val;\n    &#125; else &#123;\n        &#x2F;&#x2F; 非对称\n        return max_value;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n本次9月排名赛的四道题都放在了飞书文档公开，欢迎访问：\nhttps://bytedancecampus1.feishu.cn/docx/doxcnz5i6ZoB0PYNkUCEmoEXyRg\n\n","slug":"字节跳动九月模拟笔试（下）","date":"2022-09-08T13:57:00.000Z","categories_index":"数据结构与算法","tags_index":"数据结构,二叉树,优先队列,字节跳动","author_index":"风离"},{"id":"e0afe5470d30cea57d222ddde269ba0c","title":"JSONP解决跨域问题","content":"JSONP是JSON with Padding的略称，JSONP为民间提出的一种跨域解决方案，通过客户端的script标签发出的请求方式。\n什么时候才有跨域问题?浏览器的ajax，去请求不同的源的数据，就会出现跨域问题。\n问: img&#x2F;srcipt标签的src有跨域问题吗?\n答:没有\n所以可以利用这个解决跨域\n\n&lt;!--index.html --&gt;\n&lt;body&gt;\n    &lt;button id&#x3D;&quot;btn&quot;&gt;发送ajax请求&lt;&#x2F;button&gt;\n    &lt;script&gt;\n        &#x2F;&#x2F; 这个例子不使用Ajax请求，而是使用script标签，向服务器发送请求\n        &#x2F;&#x2F; 然后在客户端得到对应的数据\n\n        let btn &#x3D; document.querySelector(&#39;#btn&#39;);\n\n        function jsonp(options) &#123;\n            &#x2F;&#x2F; 定义一个回调函数\n            let callBackName &#x3D; &#39;wangcai&#39;;\n            &#x2F;&#x2F; 回调函数负责返回数据或者错误\n            window[callBackName] &#x3D; function (data) &#123;\n                if (data !&#x3D; null) &#123;\n                    options.success(data);\n                &#125; else &#123;\n                    options.fail();\n                &#125;\n            &#125;\n\n            let url &#x3D; options[&#39;url&#39;] + &#39;?callBack&#x3D;&#39; + callBackName;\n\n            let scriptEle &#x3D; document.createElement(&#39;script&#39;);\n            scriptEle.src &#x3D; url;\n            document.body.append(scriptEle);\n        &#125;\n\n        btn.onclick &#x3D; function () &#123;\n            jsonp(&#123;\n                url: &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;&#39;,\n                success: function (data) &#123;\n                    console.log(&quot;data&quot;, data);\n                &#125;,\n                fail: function (err) &#123;\n                    console.log(&quot;数据请求失败&quot;);\n                &#125;\n            &#125;)\n        &#125;\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n服务端的代码\n&#x2F;&#x2F; service.js\n\nlet express &#x3D; require(&#39;express&#39;);\n\nlet app &#x3D; express();\n\n&#x2F;&#x2F; 解决跨域问题\n&#x2F;&#x2F; app.all(&#39;*&#39;, function (req, res, next) &#123;\n&#x2F;&#x2F;     &#x2F;&#x2F; 设置允许跨域的域名,*代表允许任意域名跨域\n&#x2F;&#x2F;     res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n&#x2F;&#x2F;     &#x2F;&#x2F; 允许的header类型\n&#x2F;&#x2F;     res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;content-type&#39;);\n&#x2F;&#x2F;     &#x2F;&#x2F; 跨域允许的请求方式\n&#x2F;&#x2F;     res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;DELETE,PUT,POST,GET,OPTIONS&#39;);\n&#x2F;&#x2F;     if (req.method.toLowerCase() &#x3D;&#x3D; &#39;options&#39;) res.send(200); &#x2F;&#x2F; 让options 尝试请求快速结束\n&#x2F;&#x2F;     else next();\n&#x2F;&#x2F; &#125;);\n\n&#x2F;&#x2F; 改了服务器代码一定要重启服务器\n&#x2F;&#x2F; req是请求，res是响应\napp.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 当访问&#x2F; 时，响应json数据\n    &#x2F;&#x2F; res.json(&#123;\n    &#x2F;&#x2F;  name: &#39;wc&#39;,\n    &#x2F;&#x2F;  age: 18,\n    &#x2F;&#x2F; &#125;);\n\n    &#x2F;&#x2F; 响应字符串\n    &#x2F;&#x2F; res.send(&#39;hello express&#39;);\n\n    &#x2F;&#x2F; 响应一个函数调用的字符串\n    res.send(&#96;$&#123;req.query.callBack&#125;(\n        $&#123;JSON.stringify(&#123; name: &#39;z3&#39;, age: 128 &#125;)&#125;\n    )&#96;);\n&#125;);\n\n&#x2F;&#x2F; IP 127.0.0.1\n&#x2F;&#x2F; 域名  localhost\n&#x2F;&#x2F; 端口 3000\napp.listen(3000, () &#x3D;&gt; &#123;\n    console.log(&#39;server is running on 3000&#39;);\n&#125;);\n\nJSONP和AJAX请求的异同相同点：\n使用的目的一致，都是客户端向服务端请求数据，将数据拿回客户端进行处理。\n\n不同点：\najax请求是一种官方推出的请求方式，通过xhr对象去实现，jsonp是民间发明，script标签实现的请求。\najax是一个异步请求，jsonp是一个同步请求\najax存在同源检查，jsonp不存在同源检查，后端无需做解决跨域的响应头。\najax支持各种请求的方式，而jsonp只支持get请求\najax的使用更加简便，而jsonp的使用较为麻烦。\n\n","slug":"JSONP解决跨域","date":"2022-08-20T12:17:00.000Z","categories_index":"前端","tags_index":"网络请求,JSONP,Javascript","author_index":"风离"}]